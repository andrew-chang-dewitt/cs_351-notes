# C Primer: lecture weeks 2 & 3

## C is...

- imperative
- statically typed
- weakly type checked
- procedural
- low level
- source-level portability
- manual mem mgmt
- ptrs ref an address
- manual error code checking (using ints 🤮)
- manual namespace partitioning
- small, low-level libs

## Syntax & semantics

### Types

First the basic primatives:

- `char`: one byte integer (ASCII)
- `int`: integer, at least 2 bytes (can be more?? depends on platform, typically is 4 bytes) NOTE: for our purposes, we'll assume 32-bit `int`s unless told otherwise
- `float`: single prcesion (32 bits) IEEE float
- `double`: 64-bit IEEE float

Ints can be more:

- `signed` (default, need not be specified), `unsigned`
  - same storage size, but changes range because of inclusion of sign bit
- `short`, `long`
  - `sizeof (short int)` >= 16 bits
  - `sizeof (long int)` >= 32 bits
  - `sizeof (long long int)` >= 64 bits

Max long long int:
```c markdown-code-runner filename=notes/lec_02/max_long_long.c
#include <stdio.h>
#include <limits.h>

int main(void) {
  long long a;
  a = (1 << 64) - 1; // this overflows, so we actually
                     // get a wrong answer
  printf("ERROR: long long max == %d\n", a);

  // the idiomatic way:
  // FIXME: come back and add this here...
  long long b = INT64_MAX;
  printf("FIXED: long long max == %d\n", b);

  return 0;
}
```

<!-- CODE:BASH:START -->
<!-- echo '```' -->
<!-- cd notes/lec_02 -->
<!-- clang max_long_long.c -o max_long_long && ./max_long_long -->
<!-- echo '```' -->
<!-- CODE:END -->

Which outputs:

<!-- OUTPUT:START -->
<!-- ⚠️ This content is auto-generated by `markdown-code-runner`. -->
```
```

<!-- OUTPUT:END -->

It's important to remember C is weakly typed:

```c markdown-code-runner filename=notes/lec_02/weak-types.c
#include <stdio.h>

int main(void) {
  char         c = 0x41424344;
  short        s = 0x10001000;
  int          i = 'A';
  unsigned int u = -1;

  printf("'%c', %d, %X, %X\n", c, s, i, u);

  return 0;
}
```

<!-- CODE:BASH:START -->
<!-- echo '```' -->
<!-- cd notes/lec_02 -->
<!-- clang weak-types.c -o weak-types && ./weak-types -->
<!-- echo '```' -->
<!-- CODE:END -->

This sample may output surprising results when compiled & ran:

<!-- OUTPUT:START -->
<!-- ⚠️ This content is auto-generated by `markdown-code-runner`. -->
```
'D', 4096, 41, FFFFFFFF
```

<!-- OUTPUT:END -->

This happens because values are implicitly coerced to fit the declared type. Say we print the vaule we assinged to `c` as a hex number instead:

```c markdown-code-runner filename=notes/lec_02/weak-types-b.c
#include <stdio.h>

int main(void) {
  char c = 0x41424344;

  printf("%X\n", c);

  return 0;
}
```

<!-- CODE:BASH:START -->
<!-- echo '```' -->
<!-- cd notes/lec_02 -->
<!-- clang weak-types-b.c -o weak-types-b && ./weak-types-b -->
<!-- echo '```' -->
<!-- CODE:END -->

<!-- OUTPUT:START -->
<!-- ⚠️ This content is auto-generated by `markdown-code-runner`. -->
```
44
```

<!-- OUTPUT:END -->

### Operators

- Arithmetic:
  - `+`: addition
  - `-`: subtraction
  - `*`: mult
  - `/`: div
  - `%`: modulo
  - `++`: increment
  - `--`: decrement
  - `&`: bitwise AND
  - `|`: bitwise OR
  - `~`: bitwise NEGATE
- Relational: `>`, `>`, `<=`, `>=`, `==`, `!=`
- Logical: `&&`, `||`, `!`
- Assignment: `=`, `+=`, `-=`, `*=`, ...
- Ternary/Conditional: <code>_&lt;cond&gt_; **?** _&lt;expr if true&gt;_ **:** _&lt;expr if false&gt;_</code>

### booleans

No actual `bool` type, uses `int`s instead as the underlying & actual expressed type:

- `0 <- False`
- <code>_**everything else**_ <- True</code>
  - however the idomatic `True` value is `1`

Some expressions:

```c markdown-code-runner filename=notes/lec_02/bool_expr.c
#include <stdio.h>

int main(void) {
  int a = !(0);
  int b = 0 || 2;
  int c = 3 && 0 && 6;
  int d = !(1234);
  int e = !!(-1020);


  printf("%d \n%d \n%d \n%d \n%d \n", a, b, c, d, e);

  return 0;
}
```

<!-- CODE:BASH:START -->
<!-- echo '```' -->
<!-- cd notes/lec_02 -->
<!-- clang bool_expr.c -o bool_expr && ./bool_expr -->
<!-- echo '```' -->
<!-- CODE:END -->

<!-- OUTPUT:START -->
<!-- ⚠️ This content is auto-generated by `markdown-code-runner`. -->
```
1 
1 
0 
0 
1 
```

<!-- OUTPUT:END -->

### Control flow

pretty standard c-lang stuff here:

- `if`/`else`
- `switch ... case`
- `while`, `for`, `do-while`
  - `continue`/`break`

### variables

- must declare before use
- declaration allocates, even if no assignment


### functions

- closest c has to _top-level_ modules
- prodedural only, no classes/methods

#### _Declaration_ vs _ _Definition_




# Scratch space for in class questions:

```c markdown-code-runner filename=notes/lec_02/x.c
#include <stdio.h>

int main(void) {
  signed char x = 0xF;

  printf("Dec: %d\n", x);
  printf("Hex: %X\n", x);

  return 0;
}
```

<!-- CODE:BASH:START -->
<!-- echo '```' -->
<!-- cd notes/lec_02 -->
<!-- clang x.c -o x && ./x -->
<!-- echo '```' -->
<!-- CODE:END -->

<!-- OUTPUT:START -->
<!-- ⚠️ This content is auto-generated by `markdown-code-runner`. -->
```
Dec: 15
Hex: F
```

<!-- OUTPUT:END -->

## <mark>FIXME: fill in info from slides missed 1/23...</mark>

## Visibility & Lifetime

Imagine a fn like

```c
my_fn () {
  int i;

  // more happens ...
}
```

Where in memory is `i` on the computer?
Depends on memory model, but generally, we deal with an address space from `0x00..00` to `0xFF_FF_FF_FF_FF_FF_FF_FF`, which has 2^64 possible addresses, each address mapping to a single byte of space.
Thinking about a computer w/ 1GB of RAM: `1 GB = 2^10 MB = 2^20 KB = 2^30 B`, that means we're using more space than our memory has.
What gives?

OS abstractions allow us to access a virtual RAM instead, which doesn't necessarily align w/ the real underlying HW.
With this in mind, let's look again at our example & add a few other details:

```c
int a,b,c;
int num = 64;

my_fn () {
  int i;

  for (i, ...) {
    // more happens ...
  }
}
```

This gets mapped to our memory something like this:

```
|      ...       |
| ______________ |
| \\\\\\\\\\\\\\ |
| \\ reserved \\ |
| \\\\\\\\\\\\\\ |
| ______________ |
|                |
|                |
|                |
|                |
|     Stack      |
|                |
|                |
| .............. |
|                |
| i = 0          |
| ______________ |
| \\\\\\\\\\\\\\ |
| \\ reserved \\ |
| \\\\\\\\\\\\\\ |
| ______________ |
|                |
|                |
|                |
|     Heap       |
|                |
|                |
| ______________ |
| \\\\\\\\\\\\\\ |
| \\ reserved \\ |
| \\\\\\\\\\\\\\ |
| ______________ |
|                |
| bss (a.k.a.    |
| uninit. data): |
|  a, b, c = 0   |
| ______________ |
|                |
| init. data:    |
|  num = 65      |
| ______________ |
|                |
|                |
|                |
|                |
|   Code/Text    |
|                |
|                |
|                |
|                |
| ______________ |
| \\\\\\\\\\\\\\ |
| \\ reserved \\ |
| \\\\\\\\\\\\\\ |
| ______________ |
|      ...       |
```

Now, what happens to the location in memory that `i` was allocated to after `my_fn` returns and it's popped off the stack?

If we somehow retain the address of `i`, we can find out: 

<mark>TODO: let's build out this example:</mark>

```c markdown-code-runner filename=notes/lec_02/addr_after_use.c
str my_fn() {
  i = 1;

  printf('%', &i);
}

void main(void) {
  my_fn();

  // ...
  // prompt user for an address (they should enter the one rendered by my_fn)
  // str addr = ...

  printf(*addr);
}
```

Here's the example from the slides:

```c markdown-code-runner filename=notes/lec_02/visibility_a_main.c
// main.c
#include <stdio.h>

int sumWithI(int, int);

int I = 10;

int main() {
  printf("%d\n", sumWithI(1, 2));

  return 0;
}
```

```c
// sum.c
int sumWithI(int x, int y) {
  return x + y + I;
}
```

As written, this errors when compiled w/ `gcc -Wall -o demo main.c sum.c`:

```
visibility_a_sum.c:3:18: error: use of undeclared identifier 'I'
    3 |   return x + y + I;
      |                  ^
1 error generated.
```

If we rewrite `sum.c` to expect to find `I` _somewhere_:

```c markdown-code-runner filename=notes/lec_02/visibility_a_sum.c
// sum.c
int sumWithI(int x, int y) {
  int I;
  return x + y + I;
}
```

This should now compile & return `1 + 2 + 10 = 13`, right?

<!-- CODE:BASH:START -->
<!-- echo '```' -->
<!-- cd notes/lec_02 -->
<!-- gcc -Wall -o visibility_a visibility_a_main.c visibility_a_sum.c && ./visibility_a -->
<!-- echo '```' -->
<!-- CODE:END -->
<!-- OUTPUT:START -->
<!-- ⚠️ This content is auto-generated by `markdown-code-runner`. -->
```
32645
```

<!-- OUTPUT:END -->

Wait, what happened?
Let's try that again:

<!-- CODE:BASH:START -->
<!-- echo '```' -->
<!-- cd notes/lec_02 -->
<!-- gcc -Wall -o visibility_a visibility_a_main.c visibility_a_sum.c && ./visibility_a -->
<!-- echo '```' -->
<!-- CODE:END -->
<!-- OUTPUT:START -->
<!-- ⚠️ This content is auto-generated by `markdown-code-runner`. -->
```
32544
```

<!-- OUTPUT:END -->

Still not right, and also something different?
Why?

<mark> TODO: expand this using `extern` & `static` kw & answer "Why?"</mark>
