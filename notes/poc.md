# poc on running code blocks in notes:

`markdown-code-runner` can be used to execute arbitrary code blocks using a couple extra steps.
First, we use a `filename` directive in the language specification of the code block, giving a unique filename to associate with the block.
This file will be written relative to `$PYTHONPATH`, and will persist in the filesystem.
If the file exists, it will be overwritten.

```rust markdown-code-runner filename=notes/poc/poc.rs
fn main() {
    println!("Hello world from rust!");
}
```

Then, we write another code block, this time using bash to call the necessary compiler or interpretor.
For this rust example, we'll use `rustc` to compile the file & then execute the binary.
This bash script is usually not relevant to the document content, and can be written using the hidden style of executable code block supported by `markdown-code-runner`.
Finally, we tell `markdown-code-runner` where to place the bash script's output with the `OUTPUT:START` & `OUTPUT:END` comments seen at the end of the below example.

<!-- CODE:SKIP -->
````
```markdown
<!-- CODE:BASH:START -->
<!-- echo '```' -->
<!-- cd notes/poc -->
<!-- rustc poc.rs && ./poc -->
<!-- echo '```' -->
<!-- CODE:END -->

<!-- OUTPUT:START -->
This will be replaced by stdout from running script, e.g.:
```
Hello world from rust!
```
<!-- OUTPUT:END -->
```
````

<!-- CODE:BASH:START -->
<!-- echo '```' -->
<!-- cd notes/poc -->
<!-- rustc poc.rs && ./poc -->
<!-- echo '```' -->
<!-- CODE:END -->

After running `markdown-code-runner <path to this file>`, we should see something like this where we placed the `OUTPUT` comments:

<!-- OUTPUT:START -->
<!-- ⚠️ This content is auto-generated by `markdown-code-runner`. -->
```
Hello world from rust!
```

<!-- OUTPUT:END -->
